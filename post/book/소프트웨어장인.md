# 소프트웨어 장인

### 상아탑 아키텍트와 소프트웨어 장인(저자)의 논쟁

저자는 '상아탑 아키텍트'는 개발 일정과 최종 개발 산출물에는 책임을 지지 않고 한 발 물러서 있다가 프로젝트가 잘되면 자기 설계가 잘 된 것이고 프로젝트가 잘 못 되면 개발자에게 책임을 전가하는 관료주의적인 존재로 묘사한다.

문제 상황의 예시는 이렇다.
 
> 아키텍트가 명시한 기술 스택을 사용하지 않고 모듈 내부에 저자가 더 낫다고 판단한 기술을 적용했다.

과장해서 표현한다면 이런 행동의 근거는 소프트웨어 장인은 '나중에 이슈가 나오면 어차피 책임질 사람도 개발자이고, 수습하기 위해 야근할 사람도 개발자이다. 죽으면 죽었지 안되는 꼴은 못본다.' 라는 책임감으로 미연에 이슈를 방지하기 위함이라는 것이다.

아무리 외부 인터페이스에 영향을 미치지 않는 모듈 내부의 구현이라 하지만 아키텍트와 상의없이 개발자(저자)가 정하여 적용했다. 그리고 결정 사항에 대한 근거를 따로 남기지 않았고 논쟁이 벌어지고 나서야 자초지종을 따져묻는 아키텍트에게 그제서야 근거를 얘기했다.

저자는 이는 내부 모듈 구현의 문제이고 개발자의 영역이라고 주장하지만, 설계를 담당하는 아키텍트가 모듈 내부에 어떤 기술을 적용했는지 파악했다는 것 자체가 이미 뭔가 비기능(품질속성)적인 측면으로 외부로 드러났다는 반증이 아닐까. 그렇게 무책임한 '상아탑 아키텍트'가 그 사실을 어떻게 알았을까 말이다.

분명 아키텍트의 역할 중 과제에 적용될 기술 스택을 결정하는 역할이 있고, 규모가 큰 과제에서는 기술 표준화가 어느 수준까지는 필요하다는 사실을 저자도 모르는 바가 아니나, 그것을 뒤집을 만큼의 근거였는지 별다른 설명이 없다. 자칫 항상 반대편에 서는 오만한 슈퍼 개발자인 것은 아닌지 오해의 소지가 있다.

상대가 '상아탑 아키텍트' 곧 절대로 훌륭하지 않은 아키텍트라는 전제와 어떤 극단적인 상황을 예시로 하여 훌륭한 장인정신을 가진 개발자를 강조하고자 한 것이겠지만, 그래도 별로 동의가 되지 않는 부분이다. 차라리 맘대로 적용하기 전에 아키텍트와 협의를 먼저 하는 것이 서로의 역할을 침해하지 않고 과제를 진행하는 방향이 아니었을까.

끝까지 외부로 노출되지 않았으면(~~안 걸렸으면~~) 몰라도 아무래도 이건 방어를 가장한 과도한 선제 공격인 것 같다.


## 관리자에게 의미있는 표현
상대에 맞게 표현해야 한다.

* 생산성 향상
* 비용 절감
* 매출 증대
* 일정 준수
* 버그 감소
* 예측 가능하고 꾸준한 개발 속도
* 비즈니스 요구사항 충족


## 좋은 품질의 SW란
각자의 입장에서 다르게 받아들여지는 의미가 된다.

### 개발자
좋은(단순한) 설계, 변수나 함수의 네이밍, 의미 있고 가독성 높은 테스트 코드, 중복이 없고 장황하지 않은 코드

### 제품 관리자
요구사항을 모두 만족하고, 버그가 없고, 일정 준수

### 최종 고객
상용 환경하에서 돈을 벌거나, 돈을 절약하거나, 매출을 지켜주는 것


## 비범 vs 평범
비범한 개발자는 요구사항을 충족하는 가장 단순한 크도를 만들어 경험이 적은 개발자가 이해하는 데 아무런 문제가 없도록 한다. 단순하고 우아한 방법



디자인패턴(GoF)
과잉 엔지니어링에다가 복잡한 솔루션을 유도.
코드가 범용화될 수록 더 복잡



## 초기부터 큰 설계 vs 최소 요구 만족을 통한 점진적인 개발


섣부른 과잉 설계 (BDUF: big design up-front)나 과잉 엔지니어링
어느 부분에서 수정이 필요할지 모르기 때문에 모든 부분에서 추상화(복잡도 증대) 적용


실용적인 접근 방법은 실제로 필요한 상황이 생겼을 때만 추상화
주어진 문제에만 특정된 코드로 먼저 솔루션을 찾은 후 나중에 필요한 상황이 생겼을 때 범용화
